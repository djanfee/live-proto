// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.28.3
// source: game/v1/game.proto

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	LiveGameExternalService_K9GameResourceListSync_FullMethodName = "/game.v1.LiveGameExternalService/K9GameResourceListSync"
)

// LiveGameExternalServiceClient is the client API for LiveGameExternalService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LiveGameExternalServiceClient interface {
	// 获取游戏资源信息
	K9GameResourceListSync(ctx context.Context, in *GameReq, opts ...grpc.CallOption) (*GameReply, error)
}

type liveGameExternalServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLiveGameExternalServiceClient(cc grpc.ClientConnInterface) LiveGameExternalServiceClient {
	return &liveGameExternalServiceClient{cc}
}

func (c *liveGameExternalServiceClient) K9GameResourceListSync(ctx context.Context, in *GameReq, opts ...grpc.CallOption) (*GameReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GameReply)
	err := c.cc.Invoke(ctx, LiveGameExternalService_K9GameResourceListSync_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LiveGameExternalServiceServer is the server API for LiveGameExternalService service.
// All implementations must embed UnimplementedLiveGameExternalServiceServer
// for forward compatibility.
type LiveGameExternalServiceServer interface {
	// 获取游戏资源信息
	K9GameResourceListSync(context.Context, *GameReq) (*GameReply, error)
	mustEmbedUnimplementedLiveGameExternalServiceServer()
}

// UnimplementedLiveGameExternalServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedLiveGameExternalServiceServer struct{}

func (UnimplementedLiveGameExternalServiceServer) K9GameResourceListSync(context.Context, *GameReq) (*GameReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method K9GameResourceListSync not implemented")
}
func (UnimplementedLiveGameExternalServiceServer) mustEmbedUnimplementedLiveGameExternalServiceServer() {
}
func (UnimplementedLiveGameExternalServiceServer) testEmbeddedByValue() {}

// UnsafeLiveGameExternalServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LiveGameExternalServiceServer will
// result in compilation errors.
type UnsafeLiveGameExternalServiceServer interface {
	mustEmbedUnimplementedLiveGameExternalServiceServer()
}

func RegisterLiveGameExternalServiceServer(s grpc.ServiceRegistrar, srv LiveGameExternalServiceServer) {
	// If the following call pancis, it indicates UnimplementedLiveGameExternalServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&LiveGameExternalService_ServiceDesc, srv)
}

func _LiveGameExternalService_K9GameResourceListSync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GameReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LiveGameExternalServiceServer).K9GameResourceListSync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LiveGameExternalService_K9GameResourceListSync_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LiveGameExternalServiceServer).K9GameResourceListSync(ctx, req.(*GameReq))
	}
	return interceptor(ctx, in, info, handler)
}

// LiveGameExternalService_ServiceDesc is the grpc.ServiceDesc for LiveGameExternalService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LiveGameExternalService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "game.v1.LiveGameExternalService",
	HandlerType: (*LiveGameExternalServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "K9GameResourceListSync",
			Handler:    _LiveGameExternalService_K9GameResourceListSync_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "game/v1/game.proto",
}

const (
	LiveGameExternalSingleService_EnterGame_FullMethodName    = "/game.v1.LiveGameExternalSingleService/EnterGame"
	LiveGameExternalSingleService_EnterGameTry_FullMethodName = "/game.v1.LiveGameExternalSingleService/EnterGameTry"
)

// LiveGameExternalSingleServiceClient is the client API for LiveGameExternalSingleService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LiveGameExternalSingleServiceClient interface {
	// 进入游戏
	EnterGame(ctx context.Context, in *SingleEnterGameReq, opts ...grpc.CallOption) (*SingleEnterGameReply, error)
	// 进入游戏试玩
	EnterGameTry(ctx context.Context, in *SingleEnterGameTryReq, opts ...grpc.CallOption) (*SingleEnterGameTryReply, error)
}

type liveGameExternalSingleServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLiveGameExternalSingleServiceClient(cc grpc.ClientConnInterface) LiveGameExternalSingleServiceClient {
	return &liveGameExternalSingleServiceClient{cc}
}

func (c *liveGameExternalSingleServiceClient) EnterGame(ctx context.Context, in *SingleEnterGameReq, opts ...grpc.CallOption) (*SingleEnterGameReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SingleEnterGameReply)
	err := c.cc.Invoke(ctx, LiveGameExternalSingleService_EnterGame_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *liveGameExternalSingleServiceClient) EnterGameTry(ctx context.Context, in *SingleEnterGameTryReq, opts ...grpc.CallOption) (*SingleEnterGameTryReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SingleEnterGameTryReply)
	err := c.cc.Invoke(ctx, LiveGameExternalSingleService_EnterGameTry_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LiveGameExternalSingleServiceServer is the server API for LiveGameExternalSingleService service.
// All implementations must embed UnimplementedLiveGameExternalSingleServiceServer
// for forward compatibility.
type LiveGameExternalSingleServiceServer interface {
	// 进入游戏
	EnterGame(context.Context, *SingleEnterGameReq) (*SingleEnterGameReply, error)
	// 进入游戏试玩
	EnterGameTry(context.Context, *SingleEnterGameTryReq) (*SingleEnterGameTryReply, error)
	mustEmbedUnimplementedLiveGameExternalSingleServiceServer()
}

// UnimplementedLiveGameExternalSingleServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedLiveGameExternalSingleServiceServer struct{}

func (UnimplementedLiveGameExternalSingleServiceServer) EnterGame(context.Context, *SingleEnterGameReq) (*SingleEnterGameReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnterGame not implemented")
}
func (UnimplementedLiveGameExternalSingleServiceServer) EnterGameTry(context.Context, *SingleEnterGameTryReq) (*SingleEnterGameTryReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnterGameTry not implemented")
}
func (UnimplementedLiveGameExternalSingleServiceServer) mustEmbedUnimplementedLiveGameExternalSingleServiceServer() {
}
func (UnimplementedLiveGameExternalSingleServiceServer) testEmbeddedByValue() {}

// UnsafeLiveGameExternalSingleServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LiveGameExternalSingleServiceServer will
// result in compilation errors.
type UnsafeLiveGameExternalSingleServiceServer interface {
	mustEmbedUnimplementedLiveGameExternalSingleServiceServer()
}

func RegisterLiveGameExternalSingleServiceServer(s grpc.ServiceRegistrar, srv LiveGameExternalSingleServiceServer) {
	// If the following call pancis, it indicates UnimplementedLiveGameExternalSingleServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&LiveGameExternalSingleService_ServiceDesc, srv)
}

func _LiveGameExternalSingleService_EnterGame_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SingleEnterGameReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LiveGameExternalSingleServiceServer).EnterGame(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LiveGameExternalSingleService_EnterGame_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LiveGameExternalSingleServiceServer).EnterGame(ctx, req.(*SingleEnterGameReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LiveGameExternalSingleService_EnterGameTry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SingleEnterGameTryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LiveGameExternalSingleServiceServer).EnterGameTry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LiveGameExternalSingleService_EnterGameTry_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LiveGameExternalSingleServiceServer).EnterGameTry(ctx, req.(*SingleEnterGameTryReq))
	}
	return interceptor(ctx, in, info, handler)
}

// LiveGameExternalSingleService_ServiceDesc is the grpc.ServiceDesc for LiveGameExternalSingleService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LiveGameExternalSingleService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "game.v1.LiveGameExternalSingleService",
	HandlerType: (*LiveGameExternalSingleServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "EnterGame",
			Handler:    _LiveGameExternalSingleService_EnterGame_Handler,
		},
		{
			MethodName: "EnterGameTry",
			Handler:    _LiveGameExternalSingleService_EnterGameTry_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "game/v1/game.proto",
}

const (
	LiveGameExternalTransferService_EnterGame_FullMethodName                   = "/game.v1.LiveGameExternalTransferService/EnterGame"
	LiveGameExternalTransferService_WalletTransferInGame_FullMethodName        = "/game.v1.LiveGameExternalTransferService/WalletTransferInGame"
	LiveGameExternalTransferService_WalletTransferOutGame_FullMethodName       = "/game.v1.LiveGameExternalTransferService/WalletTransferOutGame"
	LiveGameExternalTransferService_GetWalletTransferBalance_FullMethodName    = "/game.v1.LiveGameExternalTransferService/GetWalletTransferBalance"
	LiveGameExternalTransferService_GetGameTransferOrderStatus_FullMethodName  = "/game.v1.LiveGameExternalTransferService/GetGameTransferOrderStatus"
	LiveGameExternalTransferService_GetGameTransferBetOrderList_FullMethodName = "/game.v1.LiveGameExternalTransferService/GetGameTransferBetOrderList"
)

// LiveGameExternalTransferServiceClient is the client API for LiveGameExternalTransferService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LiveGameExternalTransferServiceClient interface {
	// 进入游戏
	EnterGame(ctx context.Context, in *TransferEnterGameReq, opts ...grpc.CallOption) (*TransferEnterGameReply, error)
	// 转账钱包转入游戏
	WalletTransferInGame(ctx context.Context, in *WalletTransferInGameReq, opts ...grpc.CallOption) (*WalletTransferInGameReply, error)
	// 转账钱包转入
	WalletTransferOutGame(ctx context.Context, in *WalletTransferOutGameReq, opts ...grpc.CallOption) (*WalletTransferOutGameReply, error)
	// 转账钱包余额查询
	GetWalletTransferBalance(ctx context.Context, in *GetWalletTransferBalanceReq, opts ...grpc.CallOption) (*GetWalletTransferBalanceReply, error)
	// 查询用户游戏转账（转入、转出）订单状态
	GetGameTransferOrderStatus(ctx context.Context, in *GetGameTransferOrderStatusReq, opts ...grpc.CallOption) (*GetGameTransferOrderStatusReply, error)
	// 查询用户游戏投注订单列表
	GetGameTransferBetOrderList(ctx context.Context, in *GetGameTransferBetOrderListReq, opts ...grpc.CallOption) (*GetGameTransferBetOrderListReply, error)
}

type liveGameExternalTransferServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLiveGameExternalTransferServiceClient(cc grpc.ClientConnInterface) LiveGameExternalTransferServiceClient {
	return &liveGameExternalTransferServiceClient{cc}
}

func (c *liveGameExternalTransferServiceClient) EnterGame(ctx context.Context, in *TransferEnterGameReq, opts ...grpc.CallOption) (*TransferEnterGameReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TransferEnterGameReply)
	err := c.cc.Invoke(ctx, LiveGameExternalTransferService_EnterGame_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *liveGameExternalTransferServiceClient) WalletTransferInGame(ctx context.Context, in *WalletTransferInGameReq, opts ...grpc.CallOption) (*WalletTransferInGameReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WalletTransferInGameReply)
	err := c.cc.Invoke(ctx, LiveGameExternalTransferService_WalletTransferInGame_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *liveGameExternalTransferServiceClient) WalletTransferOutGame(ctx context.Context, in *WalletTransferOutGameReq, opts ...grpc.CallOption) (*WalletTransferOutGameReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WalletTransferOutGameReply)
	err := c.cc.Invoke(ctx, LiveGameExternalTransferService_WalletTransferOutGame_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *liveGameExternalTransferServiceClient) GetWalletTransferBalance(ctx context.Context, in *GetWalletTransferBalanceReq, opts ...grpc.CallOption) (*GetWalletTransferBalanceReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetWalletTransferBalanceReply)
	err := c.cc.Invoke(ctx, LiveGameExternalTransferService_GetWalletTransferBalance_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *liveGameExternalTransferServiceClient) GetGameTransferOrderStatus(ctx context.Context, in *GetGameTransferOrderStatusReq, opts ...grpc.CallOption) (*GetGameTransferOrderStatusReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetGameTransferOrderStatusReply)
	err := c.cc.Invoke(ctx, LiveGameExternalTransferService_GetGameTransferOrderStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *liveGameExternalTransferServiceClient) GetGameTransferBetOrderList(ctx context.Context, in *GetGameTransferBetOrderListReq, opts ...grpc.CallOption) (*GetGameTransferBetOrderListReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetGameTransferBetOrderListReply)
	err := c.cc.Invoke(ctx, LiveGameExternalTransferService_GetGameTransferBetOrderList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LiveGameExternalTransferServiceServer is the server API for LiveGameExternalTransferService service.
// All implementations must embed UnimplementedLiveGameExternalTransferServiceServer
// for forward compatibility.
type LiveGameExternalTransferServiceServer interface {
	// 进入游戏
	EnterGame(context.Context, *TransferEnterGameReq) (*TransferEnterGameReply, error)
	// 转账钱包转入游戏
	WalletTransferInGame(context.Context, *WalletTransferInGameReq) (*WalletTransferInGameReply, error)
	// 转账钱包转入
	WalletTransferOutGame(context.Context, *WalletTransferOutGameReq) (*WalletTransferOutGameReply, error)
	// 转账钱包余额查询
	GetWalletTransferBalance(context.Context, *GetWalletTransferBalanceReq) (*GetWalletTransferBalanceReply, error)
	// 查询用户游戏转账（转入、转出）订单状态
	GetGameTransferOrderStatus(context.Context, *GetGameTransferOrderStatusReq) (*GetGameTransferOrderStatusReply, error)
	// 查询用户游戏投注订单列表
	GetGameTransferBetOrderList(context.Context, *GetGameTransferBetOrderListReq) (*GetGameTransferBetOrderListReply, error)
	mustEmbedUnimplementedLiveGameExternalTransferServiceServer()
}

// UnimplementedLiveGameExternalTransferServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedLiveGameExternalTransferServiceServer struct{}

func (UnimplementedLiveGameExternalTransferServiceServer) EnterGame(context.Context, *TransferEnterGameReq) (*TransferEnterGameReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnterGame not implemented")
}
func (UnimplementedLiveGameExternalTransferServiceServer) WalletTransferInGame(context.Context, *WalletTransferInGameReq) (*WalletTransferInGameReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WalletTransferInGame not implemented")
}
func (UnimplementedLiveGameExternalTransferServiceServer) WalletTransferOutGame(context.Context, *WalletTransferOutGameReq) (*WalletTransferOutGameReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WalletTransferOutGame not implemented")
}
func (UnimplementedLiveGameExternalTransferServiceServer) GetWalletTransferBalance(context.Context, *GetWalletTransferBalanceReq) (*GetWalletTransferBalanceReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWalletTransferBalance not implemented")
}
func (UnimplementedLiveGameExternalTransferServiceServer) GetGameTransferOrderStatus(context.Context, *GetGameTransferOrderStatusReq) (*GetGameTransferOrderStatusReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGameTransferOrderStatus not implemented")
}
func (UnimplementedLiveGameExternalTransferServiceServer) GetGameTransferBetOrderList(context.Context, *GetGameTransferBetOrderListReq) (*GetGameTransferBetOrderListReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGameTransferBetOrderList not implemented")
}
func (UnimplementedLiveGameExternalTransferServiceServer) mustEmbedUnimplementedLiveGameExternalTransferServiceServer() {
}
func (UnimplementedLiveGameExternalTransferServiceServer) testEmbeddedByValue() {}

// UnsafeLiveGameExternalTransferServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LiveGameExternalTransferServiceServer will
// result in compilation errors.
type UnsafeLiveGameExternalTransferServiceServer interface {
	mustEmbedUnimplementedLiveGameExternalTransferServiceServer()
}

func RegisterLiveGameExternalTransferServiceServer(s grpc.ServiceRegistrar, srv LiveGameExternalTransferServiceServer) {
	// If the following call pancis, it indicates UnimplementedLiveGameExternalTransferServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&LiveGameExternalTransferService_ServiceDesc, srv)
}

func _LiveGameExternalTransferService_EnterGame_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransferEnterGameReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LiveGameExternalTransferServiceServer).EnterGame(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LiveGameExternalTransferService_EnterGame_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LiveGameExternalTransferServiceServer).EnterGame(ctx, req.(*TransferEnterGameReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LiveGameExternalTransferService_WalletTransferInGame_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WalletTransferInGameReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LiveGameExternalTransferServiceServer).WalletTransferInGame(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LiveGameExternalTransferService_WalletTransferInGame_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LiveGameExternalTransferServiceServer).WalletTransferInGame(ctx, req.(*WalletTransferInGameReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LiveGameExternalTransferService_WalletTransferOutGame_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WalletTransferOutGameReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LiveGameExternalTransferServiceServer).WalletTransferOutGame(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LiveGameExternalTransferService_WalletTransferOutGame_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LiveGameExternalTransferServiceServer).WalletTransferOutGame(ctx, req.(*WalletTransferOutGameReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LiveGameExternalTransferService_GetWalletTransferBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWalletTransferBalanceReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LiveGameExternalTransferServiceServer).GetWalletTransferBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LiveGameExternalTransferService_GetWalletTransferBalance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LiveGameExternalTransferServiceServer).GetWalletTransferBalance(ctx, req.(*GetWalletTransferBalanceReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LiveGameExternalTransferService_GetGameTransferOrderStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGameTransferOrderStatusReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LiveGameExternalTransferServiceServer).GetGameTransferOrderStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LiveGameExternalTransferService_GetGameTransferOrderStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LiveGameExternalTransferServiceServer).GetGameTransferOrderStatus(ctx, req.(*GetGameTransferOrderStatusReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LiveGameExternalTransferService_GetGameTransferBetOrderList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGameTransferBetOrderListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LiveGameExternalTransferServiceServer).GetGameTransferBetOrderList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LiveGameExternalTransferService_GetGameTransferBetOrderList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LiveGameExternalTransferServiceServer).GetGameTransferBetOrderList(ctx, req.(*GetGameTransferBetOrderListReq))
	}
	return interceptor(ctx, in, info, handler)
}

// LiveGameExternalTransferService_ServiceDesc is the grpc.ServiceDesc for LiveGameExternalTransferService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LiveGameExternalTransferService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "game.v1.LiveGameExternalTransferService",
	HandlerType: (*LiveGameExternalTransferServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "EnterGame",
			Handler:    _LiveGameExternalTransferService_EnterGame_Handler,
		},
		{
			MethodName: "WalletTransferInGame",
			Handler:    _LiveGameExternalTransferService_WalletTransferInGame_Handler,
		},
		{
			MethodName: "WalletTransferOutGame",
			Handler:    _LiveGameExternalTransferService_WalletTransferOutGame_Handler,
		},
		{
			MethodName: "GetWalletTransferBalance",
			Handler:    _LiveGameExternalTransferService_GetWalletTransferBalance_Handler,
		},
		{
			MethodName: "GetGameTransferOrderStatus",
			Handler:    _LiveGameExternalTransferService_GetGameTransferOrderStatus_Handler,
		},
		{
			MethodName: "GetGameTransferBetOrderList",
			Handler:    _LiveGameExternalTransferService_GetGameTransferBetOrderList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "game/v1/game.proto",
}

const (
	LiveGameRpcService_GameUserBet_FullMethodName        = "/game.v1.LiveGameRpcService/GameUserBet"
	LiveGameRpcService_GameUserReward_FullMethodName     = "/game.v1.LiveGameRpcService/GameUserReward"
	LiveGameRpcService_GameUserBetCancel_FullMethodName  = "/game.v1.LiveGameRpcService/GameUserBetCancel"
	LiveGameRpcService_GameUserAdjustment_FullMethodName = "/game.v1.LiveGameRpcService/GameUserAdjustment"
	LiveGameRpcService_TransferCallback_FullMethodName   = "/game.v1.LiveGameRpcService/TransferCallback"
)

// LiveGameRpcServiceClient is the client API for LiveGameRpcService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LiveGameRpcServiceClient interface {
	// 游戏投注
	GameUserBet(ctx context.Context, in *GameUserBetReq, opts ...grpc.CallOption) (*GameUserBetReply, error)
	// 订单派奖
	GameUserReward(ctx context.Context, in *GameUserRewardReq, opts ...grpc.CallOption) (*GameUserRewardReply, error)
	// 取消游戏投注
	GameUserBetCancel(ctx context.Context, in *GameUserBetCancelReq, opts ...grpc.CallOption) (*GameUserBetCancelReply, error)
	// 调账
	GameUserAdjustment(ctx context.Context, in *GameUserAdjustmentReq, opts ...grpc.CallOption) (*GameUserAdjustmentReply, error)
	// 订单回调
	TransferCallback(ctx context.Context, in *TransferCallbackReq, opts ...grpc.CallOption) (*TransferCallbackReply, error)
}

type liveGameRpcServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLiveGameRpcServiceClient(cc grpc.ClientConnInterface) LiveGameRpcServiceClient {
	return &liveGameRpcServiceClient{cc}
}

func (c *liveGameRpcServiceClient) GameUserBet(ctx context.Context, in *GameUserBetReq, opts ...grpc.CallOption) (*GameUserBetReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GameUserBetReply)
	err := c.cc.Invoke(ctx, LiveGameRpcService_GameUserBet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *liveGameRpcServiceClient) GameUserReward(ctx context.Context, in *GameUserRewardReq, opts ...grpc.CallOption) (*GameUserRewardReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GameUserRewardReply)
	err := c.cc.Invoke(ctx, LiveGameRpcService_GameUserReward_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *liveGameRpcServiceClient) GameUserBetCancel(ctx context.Context, in *GameUserBetCancelReq, opts ...grpc.CallOption) (*GameUserBetCancelReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GameUserBetCancelReply)
	err := c.cc.Invoke(ctx, LiveGameRpcService_GameUserBetCancel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *liveGameRpcServiceClient) GameUserAdjustment(ctx context.Context, in *GameUserAdjustmentReq, opts ...grpc.CallOption) (*GameUserAdjustmentReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GameUserAdjustmentReply)
	err := c.cc.Invoke(ctx, LiveGameRpcService_GameUserAdjustment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *liveGameRpcServiceClient) TransferCallback(ctx context.Context, in *TransferCallbackReq, opts ...grpc.CallOption) (*TransferCallbackReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TransferCallbackReply)
	err := c.cc.Invoke(ctx, LiveGameRpcService_TransferCallback_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LiveGameRpcServiceServer is the server API for LiveGameRpcService service.
// All implementations must embed UnimplementedLiveGameRpcServiceServer
// for forward compatibility.
type LiveGameRpcServiceServer interface {
	// 游戏投注
	GameUserBet(context.Context, *GameUserBetReq) (*GameUserBetReply, error)
	// 订单派奖
	GameUserReward(context.Context, *GameUserRewardReq) (*GameUserRewardReply, error)
	// 取消游戏投注
	GameUserBetCancel(context.Context, *GameUserBetCancelReq) (*GameUserBetCancelReply, error)
	// 调账
	GameUserAdjustment(context.Context, *GameUserAdjustmentReq) (*GameUserAdjustmentReply, error)
	// 订单回调
	TransferCallback(context.Context, *TransferCallbackReq) (*TransferCallbackReply, error)
	mustEmbedUnimplementedLiveGameRpcServiceServer()
}

// UnimplementedLiveGameRpcServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedLiveGameRpcServiceServer struct{}

func (UnimplementedLiveGameRpcServiceServer) GameUserBet(context.Context, *GameUserBetReq) (*GameUserBetReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GameUserBet not implemented")
}
func (UnimplementedLiveGameRpcServiceServer) GameUserReward(context.Context, *GameUserRewardReq) (*GameUserRewardReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GameUserReward not implemented")
}
func (UnimplementedLiveGameRpcServiceServer) GameUserBetCancel(context.Context, *GameUserBetCancelReq) (*GameUserBetCancelReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GameUserBetCancel not implemented")
}
func (UnimplementedLiveGameRpcServiceServer) GameUserAdjustment(context.Context, *GameUserAdjustmentReq) (*GameUserAdjustmentReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GameUserAdjustment not implemented")
}
func (UnimplementedLiveGameRpcServiceServer) TransferCallback(context.Context, *TransferCallbackReq) (*TransferCallbackReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransferCallback not implemented")
}
func (UnimplementedLiveGameRpcServiceServer) mustEmbedUnimplementedLiveGameRpcServiceServer() {}
func (UnimplementedLiveGameRpcServiceServer) testEmbeddedByValue()                            {}

// UnsafeLiveGameRpcServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LiveGameRpcServiceServer will
// result in compilation errors.
type UnsafeLiveGameRpcServiceServer interface {
	mustEmbedUnimplementedLiveGameRpcServiceServer()
}

func RegisterLiveGameRpcServiceServer(s grpc.ServiceRegistrar, srv LiveGameRpcServiceServer) {
	// If the following call pancis, it indicates UnimplementedLiveGameRpcServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&LiveGameRpcService_ServiceDesc, srv)
}

func _LiveGameRpcService_GameUserBet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GameUserBetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LiveGameRpcServiceServer).GameUserBet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LiveGameRpcService_GameUserBet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LiveGameRpcServiceServer).GameUserBet(ctx, req.(*GameUserBetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LiveGameRpcService_GameUserReward_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GameUserRewardReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LiveGameRpcServiceServer).GameUserReward(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LiveGameRpcService_GameUserReward_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LiveGameRpcServiceServer).GameUserReward(ctx, req.(*GameUserRewardReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LiveGameRpcService_GameUserBetCancel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GameUserBetCancelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LiveGameRpcServiceServer).GameUserBetCancel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LiveGameRpcService_GameUserBetCancel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LiveGameRpcServiceServer).GameUserBetCancel(ctx, req.(*GameUserBetCancelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LiveGameRpcService_GameUserAdjustment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GameUserAdjustmentReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LiveGameRpcServiceServer).GameUserAdjustment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LiveGameRpcService_GameUserAdjustment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LiveGameRpcServiceServer).GameUserAdjustment(ctx, req.(*GameUserAdjustmentReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LiveGameRpcService_TransferCallback_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransferCallbackReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LiveGameRpcServiceServer).TransferCallback(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LiveGameRpcService_TransferCallback_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LiveGameRpcServiceServer).TransferCallback(ctx, req.(*TransferCallbackReq))
	}
	return interceptor(ctx, in, info, handler)
}

// LiveGameRpcService_ServiceDesc is the grpc.ServiceDesc for LiveGameRpcService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LiveGameRpcService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "game.v1.LiveGameRpcService",
	HandlerType: (*LiveGameRpcServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GameUserBet",
			Handler:    _LiveGameRpcService_GameUserBet_Handler,
		},
		{
			MethodName: "GameUserReward",
			Handler:    _LiveGameRpcService_GameUserReward_Handler,
		},
		{
			MethodName: "GameUserBetCancel",
			Handler:    _LiveGameRpcService_GameUserBetCancel_Handler,
		},
		{
			MethodName: "GameUserAdjustment",
			Handler:    _LiveGameRpcService_GameUserAdjustment_Handler,
		},
		{
			MethodName: "TransferCallback",
			Handler:    _LiveGameRpcService_TransferCallback_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "game/v1/game.proto",
}
